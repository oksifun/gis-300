### Кратенький гайд по рекуррентному платежу

Главная движуха проходит в следующих файлах:
- backend/controllers/billing.py `BillingPayments` - обработка колбэков

- `RecurrentPaymentMixin` в модели **Tenant** для работы с полями настроек автоплатежа

- backend/processing/data_producers/billing/bank_processing.py - запросы в банк и получение урлы на платежную страницу
    
    Вся новая логика начинается с `_get_bank_url` и `_make_recurrent_request`. 
     
    `pay_via_recurrent_id` - функция автоплатежа по имеющемуся **recurrent_id**

- `run_accrual_docs_auto_pay_process` - таска Celery, которая запускается по крону

- Три контроллера:
    
    - `MakeFastPaymentByBank` - для быстрого платежа
    - `TenantPaymentsSettingsByBank` - работа с настройками автоплатежа жителя
    - `MakePaymentByBank` - получение ссылки на страницу оплаты банка 
    (по сути все интересное тут происходит)

#### В целом работает это все примерно так:

С FE делается запрос на `MakePaymentByBank` для получения урлы.
Рекуррент ID пытаемся получить всегда 
(сейчас это не так из-за тестов на бою, нужно параметр **autopay** передавать).


Со стороны BE делается: 
- запрос в банк для получения сессии
- POST запрос (единственный, остальные GET) с методом authenticate.do 
с запретом на редирект
- получаем ответ с 302 статусом, 
в заголовке **Location** которого лежит URL на страницу банка.
В нее добавляем два параметра, включая ранее полученный ID сессии с банком, 
чтобы банк понимал, что мы хотим получить в ответ ID рекуррентного платежа
- возвращаем полученный URL на фронт

После оплаты жителя банк должен прислать в одном из callback-запросов
 (в `BillingPayments`) **RECURRENT_ID**,
 который мы прихроним в жителя для дальнейшего использования.  